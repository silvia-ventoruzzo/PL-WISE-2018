---
title: "Listings"
author: "Silvia Ventoruzzo"
date: "27/11/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(LANG = "en")
Sys.setlocale("LC_ALL", "en_US.UTF-8")
```

```{r}
source("01_functions.R")
p_load(geosphere)
p_load(lubridate)
p_load(tidyr)
```

## Dataframe with aggregated infos about AirBnB listings in Berlin

# Load files with AirBnB listings in Berlin
One has more detailed information, while the other has only summarized information
The last one has the availability for each dy of the next year
```{r, echo = FALSE, include = FALSE}
listings_detailed <- load_listings(file.path(getwd(), "airbnb_data", "07.11_listings_detailed.csv", fsep="/"))
listings_summarized <- load_listings(file.path(getwd(), "airbnb_data", "07.11_listings_summary.csv", fsep="/"))
listings_calendar <- read.csv(file.path(getwd(), "airbnb_data", "calendar.csv", fsep="/"))
```

# Join the dataframes and clean columns of interest
```{r}
# Checking that some info is equal in both dataframes
listings_check <- dplyr::full_join(listings_summarized, listings_detailed, by = "id") %>%
  dplyr::transmute(diff_price = ifelse(price.x == price.y, TRUE, FALSE),
                  diff_room = ifelse(room_type.x == room_type.y, TRUE, FALSE),
                  diff_nights = ifelse(minimum_nights.x == minimum_nights.y, TRUE, FALSE)) %>%
  dplyr::mutate_all(funs(as.factor))
summary(listings_check)

# Join dataframes, first clean and keep only variables of interest
listings <- df_join_clean(df1 = listings_detailed, df2 = listings_summarized)

rm("listings_detailed", "listings_summarized", "listings_check")
```

# Dealing with missing values

```{r}
# Check if there are missing values
apply(listings, 2, function(x) any(is.na(x)))

# host_is_superhost
# According to airbnb: https://www.airbnb.com/help/article/828
listings %>%
  filter(is.na(host_is_superhost)) # 26

listings <- listings %>%
  dplyr::mutate(host_is_superhost = ifelse(is.na(host_is_superhost), 0, host_is_superhost))

# review_scores_rating
listings %>%
  filter(is.na(review_scores_rating)) %>%
  dplyr::select(id, review_scores_rating, number_of_reviews) # 4,389
# If the number_of_reviews is zero, we set the review_scores_value to 0 meanwhile creating a variable to keep track that the listing has not been reviewed yet
listings <- listings %>%
  dplyr::mutate(review_scores_rating = ifelse(number_of_reviews == 0, 0, review_scores_rating),
         reviewed_yn = ifelse(number_of_reviews == 0, 0, 1))
# For the rest, we insert the average of the review_scores_rating
listings %>%
  filter(is.na(review_scores_rating)) %>%
  dplyr::select(id, review_scores_accuracy, review_scores_value,
                review_scores_cleanliness, review_scores_checkin, review_scores_communication,
                review_scores_location, review_scores_rating,
                number_of_reviews) # 499

listings %>% 
  dplyr::summarize(mean = mean(review_scores_rating, na.rm = TRUE),
                   median = median(review_scores_rating, na.rm = TRUE),
                   mode = getmode(review_scores_rating)) %>%
  round(0)
# mean might be influenced by outliers, being it so different from median and mode, and mode is too high, so I will substitute the missing values with the median
listings <- listings %>%
  mutate(review_scores_rating = ifelse(is.na(review_scores_rating), 
                                       median(review_scores_rating, na.rm = TRUE),
                                       review_scores_rating))

# bedrooms and beds
listings %>%
  filter(is.na(bedrooms) | 
        is.na(beds)) %>%
  dplyr::select(id, accommodates, bedrooms, beds) # 57

# Being the amount of missing values in these features relative small, we can derive their value from the other variables:
listings <- listings %>%
                # If beds is NA, but bedrooms has a valid value, we set beds with the number of bedrooms
  dplyr::mutate(beds = ifelse(is.na(beds) & !is.na(bedrooms), bedrooms, beds),
              # If bedrooms is NA, but beds has a valid value, we set bedrooms with the number of beds
              bedrooms = ifelse(is.na(bedrooms) & !is.na(beds), beds, bedrooms),
              # If both beds and bedrooms are NA: 1
              # Since in this case the property can accomodate only one person, we assume that it has 1 bed and 1                             bedroom (even if it might not be separate)
              beds = ifelse(is.na(beds) & is.na(bedrooms), 1, beds),
              bedrooms = ifelse(beds == 1 & is.na(bedrooms), 1, bedrooms))
```

## Keep only variables of interest
```{r}
listings <- listings %>%
    # Keep only columns of interest
    dplyr::select(id, long, lat, price, property_type, room_type,
                  security_deposit_yn, cleaning_fee_yn,
                  host_is_superhost, accommodates, bedrooms, beds, minimum_nights, 
                  review_scores_rating, number_of_reviews, reviewed_yn, cancellation_policy,
                  availability_30, availability_60, availability_90, availability_365,
                  listing_url)

# Check if there are missing values
apply(listings, 2, function(x) any(is.na(x)))
```


## New features
```{r}
# district
listings <- point_in_polygons(points_df = listings,
                              polys_sf = berlin_district_sf,
                              var_name = "district")

# vbb_area
listings <- point_in_polygons(points_df = listings,
                              polys_sf = vbb_AB_sf,
                              var_name = "vbb_area")

# neighbourhood
listings <- point_in_polygons(points_df = listings,
                              polys_sf = berlin_neighbourhood_sf,
                              var_name = "neighbourhood")

# Not doing this with berlin_sf because the polys_sf need to have geometry sfc_POLYGON
```

Check for missing values and in case plot them
```{r}
listings %>%
  filter(is.na(district) | is.na(vbb_area) | is.na(neighbourhood)) %>%
  select(id, district, vbb_area, neighbourhood)
# 2
leaflet() %>%
  addTiles() %>%
  addPolygons(data = berlin_sf %>% filter(view == "Districts"), weight = 1, smoothFactor = 0.5, fillOpacity = 0.5,
              fillColor = rainbow_hcl(96), color = "black") %>%
  addLabelOnlyMarkers(data = berlin_names %>% filter(view == "Districts"),
                    lng = ~long, lat = ~lat, label = ~id, # here should be lapply(group, HTML)
                    labelOptions = labelOptions(noHide = TRUE, direction = 'center',
                                                textOnly = TRUE)) %>%
  addCircles(data = listings %>%
                    filter(is.na(district) | is.na(vbb_area) | is.na(neighbourhood)),
             lng = ~long, lat = ~lat, color = "red")
# For the sake of consistency, we will delete these listings
listings <- listings %>%
  filter(!is.na(district) & !is.na(vbb_area))
```

# Distance from stations
Firstly we need to extract all subway (U-Bahn) and railway (S-Bahn, Regio, Long-distance) stations
```{r}
# The DF stations_df is created in 02_maps.Rmd
# If U-Bahn and S-Bahn station have different coordinates, find the middle point
bahn_stations_df <- stations_df %>%
  dplyr::filter(fclass %like% "railway") %>%
  dplyr::mutate(s_bahn = ifelse(startsWith(name, "S "), TRUE, FALSE),
                u_bahn = ifelse(startsWith(name, "U "), TRUE, FALSE),
                # name = replace(name = values("^[[:alpha:]](?=\\s)", "",name)), )
                name = gsub("S ", "", name),
                name = gsub("U ", "", name)) %>%
  dplyr::group_by(name) %>%
  dplyr::summarize(long = mean(long), lat = mean(lat),
                  s_bahn = any(s_bahn), u_bahn = any(u_bahn)) %>% 
  rename(id = name)

bahn_stations_df <- point_in_polygons(points_df = bahn_stations_df,
                                      polys_sf = berlin_district_sf,
                                      var_name = "district")

# Check if there are any missing values
bahn_stations_df %>%
  filter(is.na(district))

leaflet() %>%
  addTiles() %>%
  addPolygons(data = berlin_sf %>% filter(view == "Districts"), weight = 1, smoothFactor = 0.5, fillOpacity = 0.5,
              fillColor = rainbow_hcl(96), color = "black") %>%
  addLabelOnlyMarkers(data = berlin_names %>% filter(view == "Districts"),
                    lng = ~long, lat = ~lat, label = ~id, # here should be lapply(group, HTML)
                    labelOptions = labelOptions(noHide = TRUE, direction = 'center',
                                                textOnly = TRUE)) %>%
  addCircles(data = bahn_stations_df %>%
                      filter(is.na(district)),
             lng = ~long, lat = ~lat, color = "red")
# For the sake of consistency, we will delete these listings
bahn_stations_df <- bahn_stations_df %>%
  filter(!is.na(district))

rm("stations_df")
```

Secondly we calculate the distance from the nearest station and the number of station within 1km (1000m)
```{r}
listings <- distance_count(main = listings, reference = bahn_stations_df,
                           var_name = "station", distance = 1000)
```

# Distance from top attractions
Firstly we create the dataframe with the top 10 attractions (according to visitberlin.de) with their coordinates (from Wikipedia and tools.wmflabs.org/geohack)
```{r}
attractions_df <- data.frame(
  id   = c("Reichstag", "Brandenburger Tor", "Fernsehturm", "Gendarmenmarkt",
          "Berliner Dom", "Kurfürstendamm", "Schloss Charlottenburg", "Museuminsel",
          "Gedenkstätte Berliner Mauer", "Potsdamer Platz"),
  lat  = c(52.518611, 52.516389, 52.520803, 52.513333, 52.519167, 
          52.500833, 52.521111, 52.520556, 52.535, 52.509444),
  long = c(13.376111, 13.377778, 13.40945, 13.393056, 13.401111,
           13.312778, 13.295833, 13.397222, 13.389722, 13.375833))

attractions_df <- point_in_polygons(points_df = attractions_df,
                                    polys_sf = berlin_district_sf,
                                    var_name = "district")

# Check if there are any missing values
attractions_df %>%
  filter(is.na(district))
```

Secondly we calculate the distance from the nearest attraction and the number of attractions within 2km (2000m)
```{r}
listings <- distance_count(main = listings, reference = attractions_df,
                           var_name = "attraction", distance = 2000)
```

# Calendar
```{r}
listings_calendar <- listings_calendar %>%
  rename(id = listing_id) %>%
  mutate(date        = as.Date(date),
         available   = recode(available,
                            "f" = 0,
                            "t" = 1),
         year        = lubridate::year(date),
         month       = lubridate::month(date, label = TRUE),
         day         = lubridate::day(date),
         season      = ifelse((month == "Mar" & day >= 21) | (month == "Apr") | 
                              (month == "May") | (month == "Jun" & day < 21), "Spring",
                       ifelse((month == "Jun" & day >= 21) | (month == "Jul") | 
                              (month == "Aug") | (month == "Sep" & day < 21), "Summer",
                       ifelse((month == "Sep" & day >= 21) | (month == "Oct") | 
                              (month == "Nov") | (month == "Dec" & day < 21), "Fall",
                                                                              "Winter"))) %>%
                       factor(levels = c("Spring", "Summer", "Fall", "Winter")),
         year_season = paste(year, tolower(season), sep = "_") %>%
                       factor(levels = c("2018_fall", "2018_winter", "2019_spring",
                                         "2019_summer", "2019_fall", "2019_winter"))) %>%
  dplyr::select(-price)

# Availability per year_season
listings_season_availability <- listings_calendar %>% 
  dplyr::group_by(id, year_season) %>% 
  dplyr::summarize(count = sum(available)) %>% 
  arrange(id, year_season) %>%
  ungroup() %>%
  mutate(season_av =  paste(year_season, "availability", sep = "_") %>%
                      tolower() %>%
                      factor(levels = unique(tolower(paste(year_season, "availability", sep = "_"))))) %>%
  dplyr::select(-year_season) 

listings_district_season_availability <- listings %>%
  select(id, district) %>%
  inner_join(listings_season_availability, by = "id") %>%
  group_by(district, season_av) %>%
  dplyr::summarize(count = mean(count) %>% round(0)) %>%
  spread(season_av, count)

listings_vbb_season_availability <- listings %>%
  select(id, vbb_area) %>%
  inner_join(listings_season_availability, by = "id") %>%
  group_by(vbb_area, season_av) %>%
  dplyr::summarize(count = mean(count) %>% round(0)) %>%
  spread(season_av, count)

listings_neighbourhood_season_availability <- listings %>%
  select(id, neighbourhood) %>%
  inner_join(listings_season_availability, by = "id") %>%
  group_by(neighbourhood, season_av) %>%
  dplyr::summarize(count = mean(count) %>% round(0)) %>%
  spread(season_av, count)

listings_season_availability <- listings_season_availability %>%
  spread(season_av, count)

# Join to the listings
listings <- listings %>%
  left_join(listings_season_availability, by = "id") %>%
  replace(is.na(.), 0)

rm("listings_calendar", "listings_season_availability")
```


## Summary dataframe
Variables to summarize:
- price: mean (all and pro district)
- review_scores_value: mean (all and pro district)
- property_type: how many pro type (all and pro district)
- room_type: how many pro type (all and pro district)
- cancellation_policy: how many pro type (all and pro district)
```{r}
# For all Berlin
listings_summary <- summarize_df(df = listings,
                                 vars_mean = c("price", "review_scores_rating"),
                                 vars_count = c("property_type", "room_type",
                                                "cancellation_policy"))

# For each VBB Area
listings_vbb_summary <- summarize_df(df = listings,
                                 wrt = "vbb_area",
                                 vars_mean = c("price", "review_scores_rating"),
                                 vars_count = c("property_type", "room_type",
                                                "cancellation_policy"))

listings_vbb_summary <- listings_vbb_summary %>%
  left_join(listings_vbb_season_availability, by = "vbb_area") %>%
  rename(id    = vbb_area) %>%
  mutate(view  = "VBB Areas",
         group = id)

# For each district
listings_district_summary <- summarize_df(df = listings,
                                 wrt = "district",
                                 vars_mean = c("price", "review_scores_rating"),
                                 vars_count = c("property_type", "room_type",
                                                "cancellation_policy"))

listings_district_summary <- listings_district_summary %>%
  left_join(listings_district_season_availability, by = "district") %>%
  rename(id    = district) %>%
  mutate(view  = "Districts",
         group = id)

listings_neighbourhood_summary <- summarize_df(df = listings,
                                 wrt = "neighbourhood",
                                 vars_mean = c("price", "review_scores_rating"),
                                 vars_count = c("property_type", "room_type",
                                                "cancellation_policy"))

listings_neighbourhood_summary <- listings_neighbourhood_summary <- berlin_names %>%
  dplyr::filter(view == "Neighbourhoods") %>%
  dplyr::select(id, group) %>%
  dplyr::rename(neighbourhood = id) %>%
  dplyr::left_join(listings_neighbourhood_summary, by = "neighbourhood") %>%
  dplyr::left_join(listings_neighbourhood_season_availability, by = "neighbourhood") %>%
  dplyr::rename(id = neighbourhood) %>%
  dplyr::mutate(view = "Neighbourhoods") %>%
  replace(is.na(.), 0)

rm("listings_vbb_season_availability", "listings_district_season_availability", "listings_neighbourhood_season_availability")
```

Join the area summaries to make it easy to plot them
```{r}
listings_area_summary <- rbind(listings_district_summary, listings_vbb_summary, listings_neighbourhood_summary)

rm("listings_district_summary", "listings_vbb_summary", "listings_neighbourhood_summary")
```


List of dataframes that I still need

```{r}
rm("vbb_AB_sf", "berlin_neighbourhood_sf", "berlin_district_sf")
attractions_df
bahn_stations_df
berlin_sf
berlin_center
berlin_names
listings
listings_area_summary
listings_summary
```